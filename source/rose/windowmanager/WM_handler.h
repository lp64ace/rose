#ifndef WM_HANDLER_H
#define WM_HANDLER_H

#include "LIB_listbase.h"
#include "LIB_utildefines.h"

#include "WM_event.h"

#ifdef __cplusplus
extern "C" {
#endif

struct ARegion;
struct ScrArea;
struct rContext;
struct wmEvent;
struct wmWindow;

/* -------------------------------------------------------------------- */
/** \name Data Structures
 * \{ */

typedef struct wmEvent {
	struct wmEvent *prev, *next;

	int type;
	int flag;

	int value;			 // Indicates the operation, press, release, etc.
	int mouse_xy[2];	 // Mouse pointer position, window client coord.
	int mouse_local[2];	 // Region relative mouse position.
	int modifier;		 // The currently pressed modifier keys.
	char input[4];

	// event state information

	int prev_type;	 // The previous value of `wmEvent.type`.
	int prev_value;	 // The previous value of `wmEvent.value`.
	int prev_xy[2];	 // The previous value of `wmEvent.xy`, updated per motion.

	// event state information, since the last `wmEvent.value == KM_PRESS`.

	int prev_press_type;	  // The value of `wmEvent.type` when `wmEvent.value == KM_PRESS`.
	int prev_press_xy[2];	  // The value of `wmEvent.xy` when `wmEvent.value == KM_PRESS`.
	int prev_press_modifier;  // The value of `wmEvent.modifier` when `wmEvent.value == KM_PRESS`.
} wmEvent;

/** #wmEvent->flag */
enum {
	/**
	 * Indicates that this event was generated by auto-repeat,
	 * note that this must only ever be set for keyboard events `ISKEYBOARD(event->type) == true`.
	 */
	WM_EVENT_IS_REPEAT = 1 << 0,
};

/** #wmEvent->value */
enum {
	KM_ANY = -1,
	KM_NOTHING = 0,
	KM_PRESS = 1,
	KM_RELEASE = 2,
	KM_CLICK = 3,
	KM_DBL_CLICK = 3,
	/**
	 * \note The cursor location at the point dragging start is set to #wmEvent->old.[xy]
	 *
	 */
	KM_CLICK_DRAG = 5,
};

/**
 * Alternate define for #wmKeyMapItem::shift and other modifiers.
 * While this matches the value of #KM_PRESS, modifiers should only be compared with:
 * (#KM_ANY, #KM_NOTHING, #KM_MOD_HELD).
 */
#define KM_MOD_HELD 1

/** #wmEvent->modifier */
enum {
	KM_SHIFT = 1 << 0,
	KM_CTRL = 1 << 1,
	KM_ALT = 1 << 2,
	KM_OSKEY = 1 << 3,
};

typedef bool (*EventHandlerPoll)(const struct ARegion *, const struct wmEvent *);

typedef struct wmEventHandler {
	struct wmEventHandler *prev, *next;

	int type;
	int flag;

	EventHandlerPoll poll;
} wmEventHandler;

/** #wmHandler->type */
enum {
	WM_HANDLER_TYPE_UI = 1,
	WM_HANDLER_TYPE_OP = 2,
	WM_HANDLER_TYPE_KEYMAP = 3,
};

/** #wmHandler->flag */
enum {
	/** Handler tagged to be freed. */
	WM_HANDLER_DO_FREE = 1 << 0,
	/** After this handler all others are ignored. */
	WM_HANDLER_BLOCKING = 1 << 1,
};

typedef int (*wmUIHandlerFunc)(struct rContext *C, const struct wmEvent *event, void *userdata);
typedef void (*wmUIHandlerRemoveFunc)(struct rContext *C, void *userdata);

#define WM_UI_HANDLER_CONTINUE 0
#define WM_UI_HANDLER_BREAK 1

typedef struct wmEventHandler_UI {
	wmEventHandler head;

	wmUIHandlerFunc handle_fn;
	wmUIHandlerRemoveFunc remove_fn;
	/** Associated user data to call the handle function with. */
	void *user_data;

	struct {
		struct ScrArea *area;
		struct ARegion *region;
	} context;
} wmEventHandler_UI;

typedef struct wmEventHandler_Op {
	wmEventHandler head;

	struct wmOperator *op;

	struct {
		/**
		 * To override the window, and hence the screen.
		 * Set for few cases only, usually window/screen can be taken from current context.
		 */
		wmWindow *window;

		ScrArea *area;
		ARegion *region;
		short regiontype;
	} context;
} wmEventHandler_Op;

typedef struct wmEventHandler_Keymap {
	wmEventHandler head;

	/** Pointer to builtin/custom keymaps (never NULL). */
	wmKeyMap *keymap;
} wmEventHandler_Keymap;

/** \} */

/* -------------------------------------------------------------------- */
/** \name Main Methods
 * \{ */

void WM_do_handlers(struct rContext *C);
void WM_event_remove_handlers(struct rContext *C, ListBase *handlers);
void WM_event_modal_handler_area_replace(struct wmWindow *win, const struct ScrArea *old_area, struct ScrArea *new_area);
void WM_event_modal_handler_region_replace(struct wmWindow *win, const struct ARegion *old_region, struct ARegion *new_region);

/** \} */

/* -------------------------------------------------------------------- */
/** \name UI Handle Methods
 * \{ */

struct wmEventHandler_UI *WM_event_add_ui_handler(const struct rContext *C, ListBase *handlers, wmUIHandlerFunc handle_fn, wmUIHandlerRemoveFunc remove_fn, void *userdata, int flag);
void WM_event_remove_ui_handler(ListBase *handlers, wmUIHandlerFunc handle_fn, wmUIHandlerRemoveFunc remove_fn, void *user_data, bool postpone);
void WM_event_free_ui_handler_all(struct rContext *C, ListBase *handlers, wmUIHandlerFunc handle_fn, wmUIHandlerRemoveFunc remove_fn);

/** \} */

/* -------------------------------------------------------------------- */
/** \name Keymap Handle Methods
 * \{ */

struct wmEventHandler_Keymap *WM_event_add_keymap_handler(struct ListBase *handlers, struct wmKeyMap *keymap);

/** \} */

/* -------------------------------------------------------------------- */
/** \name Op Handle Methods
 * \{ */

struct wmEventHandler_Op *WM_event_add_modal_handler_ex(struct wmWindow *window, struct ScrArea *area, struct ARegion *region, struct wmOperator *op);
struct wmEventHandler_Op *WM_event_add_modal_handler(struct rContext *C, struct wmOperator *op);
void WM_event_remove_modal_handler(struct ListBase *handlers, struct wmOperator *op, bool postpone);
void WM_event_free_modal_handler_all(struct wmWindow *window, struct wmOperator *op, bool postpone);

/** \} */

#ifdef __cplusplus
}
#endif

#endif	// WM_HANDLER_H
